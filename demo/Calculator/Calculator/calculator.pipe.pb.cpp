// Generated by the protocol buffer pipe pluging.  DO NOT EDIT!
// source: calculator.proto

#include "calculator.pipe.pb.h"
#include "libProtobufPipePlugin/PipeMessages.pb.h"

using namespace ::libProtobufPipePlugin;

namespace calculus
{
namespace CalculatorService
{
  static const std::string kPackage = "calculus";
  static const std::string kService = "CalculatorService";

  Client::Client(Connection * connection) : connection_(connection)
  {
  }

  Client::~Client()
  {
    if (connection_)
      delete connection_;
    connection_ = NULL;
  }

  Status Client::Add(const AddRequest & request, AddResponse & response)
  {
    Status status = ProcessCall("Add", request, response);
    return status;
  }

  Status Client::ProcessCall(const char * name, const ::google::protobuf::Message & request, ::google::protobuf::Message & response)
  {
    ClientRequest client_message;

    //function_identifier
    client_message.mutable_function_identifier()->set_package(kPackage.c_str());
    client_message.mutable_function_identifier()->set_service(kService.c_str());
    client_message.mutable_function_identifier()->set_function_name(name);

    // Serialize the request message into ClientRequest
    bool success = request.SerializeToString(client_message.mutable_request_buffer());
    if (!success)
      return Status::Factory::Serialization(__FUNCTION__, request);

    // Serialize the client_message ready for sending to the connection
    std::string write_buffer;
    success = client_message.SerializeToString(&write_buffer);
    if (!success)
      return Status::Factory::Serialization(__FUNCTION__, request);

    // Send
    Status status = connection_->Write(write_buffer);
    if (!status.Success())
      return status;

    // Wait for a response.
    std::string read_buffer;
    status = connection_->Read(read_buffer);
    if (!status.Success())
      return status;

    // Deserialize server's response
    ServerResponse server_response;
    success = server_response.ParseFromString(read_buffer);
    if (!success)
      return Status::Factory::Deserialization(__FUNCTION__, server_response);

    // Read server status
    if (!server_response.has_status())
      return Status::Factory::MissingField(__FUNCTION__, "status", server_response);

    // Convert ServerStatus to Status
    status.SetCode( static_cast<StatusCode>(server_response.status().code()) );
    status.SetMessage(server_response.status().description());
    if (!status.Success())
      return status;

    // Deserialize response message
    response.ParseFromString(server_response.response_buffer());
    if (!success)
      return Status::Factory::Deserialization(__FUNCTION__, response);

    // Success
    return Status::OK;
  }

  ServerStub::ServerStub()
  {
    functions_.push_back("Add");
  }

  ServerStub::~ServerStub()
  {
  }

  const std::string & ServerStub::GetPackageName() const
  {
    return kPackage;
  }

  const std::string & ServerStub::GetServiceName() const
  {
    return kService;
  }

  const std::vector<std::string> & ServerStub::GetFunctionIdentifiers() const
  {
    return functions_;
  }

  libProtobufPipePlugin::Status ServerStub::DispatchMessage(const size_t & index, const std::string & input, std::string & output)
  {
    switch(index)
    {
    case 0:
      {
        AddRequest request;
        AddResponse response;
        bool success = request.ParseFromString(input);
        if (!success)
          return Status::Factory::Deserialization(__FUNCTION__, request);
        Status status = this->Add(request, response);
        if (!status.Success())
          return status;
        success = response.SerializeToString(&output);
        if (!success)
          return Status::Factory::Serialization(__FUNCTION__, response);
      }
      break;
    default:
      //Not implemented
      return Status(STATUS_CODE_NOT_IMPLEMENTED, "Function at index " + std::to_string((unsigned long long)index) + " is not implemented.");
    };

    return Status::OK;
  }

}; //namespace CalculatorService
}; //namespace calculus

// Generated by the protocol buffer pipe pluging.  DO NOT EDIT!
// source: calculator.proto

#include "calculator.pipe.pb.h"
#include "libProtobufPipePlugin/PipeMessages.pb.h"

using namespace ::libProtobufPipePlugin;

namespace calculus
{
namespace CalculatorService
{
  static const std::string kPackage = "calculus";
  static const std::string kService = "CalculatorService";

  Client::Client(Connection * connection) : connection_(connection)
  {
  }

  Client::~Client()
  {
    if (connection_)
      delete connection_;
    connection_ = NULL;
  }

  Status Client::Add(const AddRequest & request, AddResponse & response)
  {
    Status status = ProcessMethod(kPackage.c_str(), kService.c_str(), "Add", request, response);
    return status;
  }

  Status Client::ProcessMethod(const char * package, const char * service, const char * function_name, const ::google::protobuf::Message & request, ::google::protobuf::Message & response)
  {
    ClientRequest client_message;

    //function_identifier
    client_message.mutable_function_identifier()->set_package(package);
    client_message.mutable_function_identifier()->set_service(service);
    client_message.mutable_function_identifier()->set_function_name(function_name);

    // Serialize the request message into ClientRequest
    bool success = request.SerializeToString(client_message.mutable_request_buffer());
    if (!success)
      return Status::BuildSerializationStatus(__FUNCTION__, request);

    // Serialize the client_message ready for sending to the connection
    std::string write_buffer;
    success = client_message.SerializeToString(&write_buffer);
    if (!success)
      return Status::BuildSerializationStatus(__FUNCTION__, request);

    // Send
    Status status = connection_->Write(write_buffer);
    if (!status.Success())
      return status;

    // Wait for a response.
    std::string read_buffer;
    status = connection_->Read(read_buffer);
    if (!status.Success())
      return status;

    // Deserialize server's response
    ServerResponse server_response;
    success = server_response.ParseFromString(read_buffer);
    if (!success)
      return Status::BuildDeserializationStatus(__FUNCTION__, server_response);

    // Read server status
    if (!server_response.has_status())
      return Status::BuildMissingFieldStatus(__FUNCTION__, "status", server_response);

    // Convert ServerStatus to Status
    status.SetCode( static_cast<StatusCode>(server_response.status().code()) );
    status.SetMessage(server_response.status().description());
    if (!status.Success())
      return status;

    // Deserialize response message
    response.ParseFromString(server_response.response_buffer());
    if (!success)
      return Status::BuildDeserializationStatus(__FUNCTION__, response);

    // Success
    return Status::OK;
  }

  ServerStub::ServerStub()
  {
    functions_.push_back("Add");
  }

  ServerStub::~ServerStub()
  {
  }

  const std::string & ServerStub::GetPackageName() const
  {
    return kPackage;
  }

  const std::string & ServerStub::GetServiceName() const
  {
    return kService;
  }

  const std::vector<std::string> & ServerStub::GetFunctionIdentifiers() const
  {
    return functions_;
  }

  libProtobufPipePlugin::Status ServerStub::DispatchMessage(const size_t & index, const std::string & input, std::string & output)
  {
    bool success = false;
    Status status;

    switch(index)
    {
    case 0:
      {
        AddRequest request;
        AddResponse response;
        success = request.ParseFromString(input);
        if (!success)
        {
          status = Status::BuildDeserializationStatus(__FUNCTION__, request);
          break;
        }
        status = this->Add(request, response);
        if (!status.Success())
          break;
        success = response.SerializeToString(&output);
        if (!success)
          status = Status::BuildSerializationStatus(__FUNCTION__, response);
      }
      break;
    default:
      //Not implemented
      std::string error_message = "Function at index " + std::to_string((unsigned long long)index) + " is not implemented.";
      status.SetCode(STATUS_CODE_NOT_IMPLEMENTED);
      status.SetMessage(error_message);
    };

    return status;
  }

}; //namespace CalculatorService
}; //namespace calculus

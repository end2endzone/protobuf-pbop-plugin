/**********************************************************************************
 * MIT License
 * 
 * Copyright (c) 2018 Antoine Beauchamp
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *********************************************************************************/

#include "PluginCodeGenerator.h"
#include <google/protobuf/compiler/cpp/cpp_generator.h>

#include <sstream>  //for std::stringstream

#include "StreamPrinter.h"
#include "DebugPrinter.h"
#include "pbop.h"
#include "pbop/version.h"

//for debugging
#include <Windows.h>

PluginCodeGenerator::PluginCodeGenerator()
{
#if 0
  const std::string exe_path = ra::process::GetCurrentProcessPath();
  const std::string exe_filename = ra::filesystem::GetFilename(exe_path.c_str());
  std::string message = __FUNCTION__;
  MessageBoxA(NULL,message.c_str(), exe_filename.c_str(), MB_OK + MB_ICONEXCLAMATION);
  int a = 0;
#endif
}

PluginCodeGenerator::~PluginCodeGenerator()
{
}

bool PluginCodeGenerator::GenerateHeader(const google::protobuf::FileDescriptor * file, const std::string & parameter, google::protobuf::compiler::GeneratorContext * generator_context, std::string * error) const
{
  const std::string & proto_filename = file->name();
  const std::string proto_filename_we = pbop::GetFilenameWithoutExtension(proto_filename.c_str());
  const std::string header_filename = proto_filename_we + ".pbop.pb.h";
  const std::string cpp_filename = proto_filename_we + ".pbop.pb.cc";
  const std::string header_guard = "PROTOBUF_" + pbop::Uppercase(proto_filename_we) + "_PBOP_H";

  std::stringstream ss;

  ss << "// Generated by the protocol buffer pbop pluging v" << PBOP_VERSION << ".  DO NOT EDIT!\n";
  ss << "// https://github.com/end2endzone/protobuf-pbop-plugin\n";
  ss << "// source: " << proto_filename << "\n";
  ss << "\n";
  ss << "#ifndef " << header_guard << "\n";
  ss << "#define " << header_guard << "\n";
  ss << "\n";
  ss << "#include \"" << proto_filename_we << ".pb.h\"\n";
  ss << "\n";
  ss << "#include \"pbop/Status.h\"\n";
  ss << "#include \"pbop/Service.h\"\n";
  ss << "#include \"pbop/Connection.h\"\n";
  ss << "\n";
  ss << "#include <string>\n";
  ss << "\n";
  ss << "namespace " << file->package() << " {\n";


  //for each services
  int num_services = file->service_count();
  for(int i=0; i<num_services; i++)
  {
    const google::protobuf::ServiceDescriptor * service = file->service(i);
    const std::string service_fullname = service->full_name();
    const std::string & service_name = service->name();

    ss << "  class " << service_name << " {\n";
    ss << "    public:\n";
    ss << "    \n";
    ss << "    class StubInterface {\n";
    ss << "    public:\n";
    ss << "      virtual ~StubInterface() {}\n";

    //for each methods
    int num_methods = service->method_count();
    for(int j=0; j<num_methods; j++)
    {
      const google::protobuf::MethodDescriptor * method = service->method(j);
      const std::string method_fullname = method->full_name();
      const std::string & method_name = method->name();

      const google::protobuf::Descriptor * method_input = method->input_type();
      const std::string method_input_fullname = method_input->full_name();
      const std::string & method_input_name = method_input->name();

      const google::protobuf::Descriptor * method_output = method->output_type();
      const std::string method_output_fullname = method_output->full_name();
      const std::string & method_output_name = method_output->name();

      ss << "      virtual pbop::Status " << method_name << "(const " << method_input_name << " & request, " << method_output_name << " & response) = 0;\n";
    }

    ss << "    }; // class StubInterface\n";
    ss << "  \n";
    ss << "    class Client : public virtual StubInterface {\n";
    ss << "    public:\n";
    ss << "      Client(pbop::Connection * connection);\n";
    ss << "      virtual ~Client();\n";

    //for each methods
    for(int j=0; j<num_methods; j++)
    {
      const google::protobuf::MethodDescriptor * method = service->method(j);
      const std::string method_fullname = method->full_name();
      const std::string & method_name = method->name();

      const google::protobuf::Descriptor * method_input = method->input_type();
      const std::string method_input_fullname = method_input->full_name();
      const std::string & method_input_name = method_input->name();

      const google::protobuf::Descriptor * method_output = method->output_type();
      const std::string method_output_fullname = method_output->full_name();
      const std::string & method_output_name = method_output->name();

      ss << "      virtual pbop::Status " << method_name << "(const " << method_input_name << " & request, " << method_output_name << " & response);\n";
    }

    ss << "    private:\n";
    ss << "      pbop::Status ProcessCall(const char * name, const ::google::protobuf::Message & request, ::google::protobuf::Message & response);\n";
    ss << "      pbop::Connection * connection_;\n";
    ss << "    }; // class Client\n";
    ss << "    \n";
    ss << "    class Service : public virtual StubInterface, public virtual pbop::Service {\n";
    ss << "    public:\n";
    ss << "      Service();\n";
    ss << "      virtual ~Service();\n";
    ss << "      virtual const char * GetPackageName() const;\n";
    ss << "      virtual const char * GetServiceName() const;\n";
    ss << "      virtual const char ** GetFunctionIdentifiers() const;\n";
    ss << "      virtual pbop::Status InvokeMethod(const size_t & index, const std::string & input, std::string & output);\n";

    //for each methods
    for(int j=0; j<num_methods; j++)
    {
      const google::protobuf::MethodDescriptor * method = service->method(j);
      const std::string method_fullname = method->full_name();
      const std::string & method_name = method->name();

      const google::protobuf::Descriptor * method_input = method->input_type();
      const std::string method_input_fullname = method_input->full_name();
      const std::string & method_input_name = method_input->name();

      const google::protobuf::Descriptor * method_output = method->output_type();
      const std::string method_output_fullname = method_output->full_name();
      const std::string & method_output_name = method_output->name();

      ss << "      inline pbop::Status " << method_name << "(const " << method_input_name << " & request, " << method_output_name << " & response) { return pbop::Status::Factory::NotImplemented(__FUNCTION__); }\n";
    }

    ss << "    };  // class Service\n";
    ss << "  \n";
    ss << "  }; // class " << service_name << "\n";
  }

  ss << "}; //namespace " << file->package() << "\n";
  ss << "\n";
  ss << "#endif //" << header_guard << "\n";


  //output to header file
  google::protobuf::io::ZeroCopyOutputStream * stream = generator_context->Open(header_filename.c_str());
  StreamPrinter printer(stream); //StreamPrinter takes ownership of the Stream
  const std::string buffer = ss.str();
  printer.Print(buffer.c_str(), buffer.size());

  return true;
}

bool PluginCodeGenerator::GenerateSource(const google::protobuf::FileDescriptor * file, const std::string & parameter, google::protobuf::compiler::GeneratorContext * generator_context, std::string * error) const
{
  const std::string & proto_filename = file->name();
  const std::string proto_filename_we = pbop::GetFilenameWithoutExtension(proto_filename.c_str());
  const std::string header_filename = proto_filename_we + ".pbop.pb.h";
  const std::string cpp_filename = proto_filename_we + ".pbop.pb.cc";
  const std::string header_guard = "PROTOBUF_" + pbop::Uppercase(proto_filename_we) + "_PBOP_H";

  std::stringstream ss;

  ss << "// Generated by the protocol buffer pbop pluging v" << PBOP_VERSION << ".  DO NOT EDIT!\n";
  ss << "// https://github.com/end2endzone/protobuf-pbop-plugin\n";
  ss << "// source: " << proto_filename << "\n";
  ss << "\n";
  ss << "#include \"" << proto_filename_we << ".pbop.pb.h\"\n";
  ss << "#include \"pbop/pbop.pb.h\"\n";
  ss << "\n";
  ss << "using namespace ::pbop;\n";
  ss << "\n";
  ss << "namespace " << file->package() << " {\n";

  //for each services
  int num_services = file->service_count();
  for(int i=0; i<num_services; i++)
  {
    const google::protobuf::ServiceDescriptor * service = file->service(i);
    const std::string service_fullname = service->full_name();
    const std::string & service_name = service->name();
    
    ss << "\n";
    ss << "  " << service_name << "::Client::Client(Connection * connection) : connection_(connection) {\n";
    ss << "  }\n";
    ss << "  \n";
    ss << "  " << service_name << "::Client::~Client() {\n";
    ss << "    if (connection_)\n";
    ss << "      delete connection_;\n";
    ss << "    connection_ = NULL;\n";
    ss << "  }\n";
    ss << "  \n";

    //for each methods
    int num_methods = service->method_count();
    for(int j=0; j<num_methods; j++)
    {
      const google::protobuf::MethodDescriptor * method = service->method(j);
      const std::string method_fullname = method->full_name();
      const std::string & method_name = method->name();

      const google::protobuf::Descriptor * method_input = method->input_type();
      const std::string method_input_fullname = method_input->full_name();
      const std::string & method_input_name = method_input->name();

      const google::protobuf::Descriptor * method_output = method->output_type();
      const std::string method_output_fullname = method_output->full_name();
      const std::string & method_output_name = method_output->name();

      ss << "  Status " << service_name << "::Client::" << method_name << "(const " << method_input_name << " & request, " << method_output_name << " & response)\n";
      ss << "  {\n";
      ss << "    Status status = ProcessCall(\"" << method_name << "\", request, response);\n";
      ss << "    return status;\n";
      ss << "  }\n";
      ss << "  \n";
    }

    ss << "  Status " << service_name << "::Client::ProcessCall(const char * name, const ::google::protobuf::Message & request, ::google::protobuf::Message & response)\n";
    ss << "  {\n";
    ss << "    ClientRequest client_message;\n";
    ss << "    \n";
    ss << "    //function_identifier\n";
    ss << "    client_message.mutable_function_identifier()->set_package(\"" << file->package() << "\");\n";
    ss << "    client_message.mutable_function_identifier()->set_service(\"" << service_name << "\");\n";
    ss << "    client_message.mutable_function_identifier()->set_function_name(name);\n";
    ss << "    \n";
    ss << "    // Serialize the request message into ClientRequest\n";
    ss << "    bool success = request.SerializeToString(client_message.mutable_request_buffer());\n";
    ss << "    if (!success)\n";
    ss << "      return Status::Factory::Serialization(__FUNCTION__, request);\n";
    ss << "    \n";
    ss << "    // Serialize the client_message ready for sending to the connection\n";
    ss << "    std::string write_buffer;\n";
    ss << "    success = client_message.SerializeToString(&write_buffer);\n";
    ss << "    if (!success)\n";
    ss << "      return Status::Factory::Serialization(__FUNCTION__, request);\n";
    ss << "    \n";
    ss << "    // Send\n";
    ss << "    Status status = connection_->Write(write_buffer);\n";
    ss << "    if (!status.Success())\n";
    ss << "      return status;\n";
    ss << "    \n";
    ss << "    // Wait for a response.\n";
    ss << "    std::string read_buffer;\n";
    ss << "    status = connection_->Read(read_buffer);\n";
    ss << "    if (!status.Success())\n";
    ss << "      return status;\n";
    ss << "    \n";
    ss << "    // Deserialize server's response\n";
    ss << "    ServerResponse server_response;\n";
    ss << "    success = server_response.ParseFromString(read_buffer);\n";
    ss << "    if (!success)\n";
    ss << "      return Status::Factory::Deserialization(__FUNCTION__, server_response);\n";
    ss << "    \n";
    ss << "    // Read server status\n";
    ss << "    if (!server_response.has_status())\n";
    ss << "      return Status::Factory::MissingField(__FUNCTION__, \"status\", server_response);\n";
    ss << "    \n";
    ss << "    // Convert StatusMessage to Status\n";
    ss << "    status.SetCode( static_cast<StatusCode>(server_response.status().code()) );\n";
    ss << "    status.SetDescription(server_response.status().description());\n";
    ss << "    if (!status.Success())\n";
    ss << "      return status;\n";
    ss << "    \n";
    ss << "    // Deserialize response message\n";
    ss << "    response.ParseFromString(server_response.response_buffer());\n";
    ss << "    if (!success)\n";
    ss << "      return Status::Factory::Deserialization(__FUNCTION__, response);\n";
    ss << "    \n";
    ss << "    // Success\n";
    ss << "    return Status::OK;\n";
    ss << "  }\n";
    ss << "  \n";
    ss << "  " << service_name << "::Service::Service() {\n";
    ss << "  }\n";
    ss << "  \n";
    ss << "  " << service_name << "::Service::~Service() {\n";
    ss << "  }\n";
    ss << "  \n";
    ss << "  const char * " << service_name << "::Service::GetPackageName() const {\n";
    ss << "    return \"" << file->package() << "\";\n";
    ss << "  }\n";
    ss << "  \n";
    ss << "  const char * " << service_name << "::Service::GetServiceName() const {\n";
    ss << "    return \"" << service_name << "\";\n";
    ss << "  }\n";
    ss << "  \n";
    ss << "  const char ** " << service_name << "::Service::GetFunctionIdentifiers() const {\n";
    ss << "    static const char * identifiers[] = {\n";

    //for each methods
    for(int j=0; j<num_methods; j++)
    {
      const google::protobuf::MethodDescriptor * method = service->method(j);
      const std::string method_fullname = method->full_name();
      const std::string & method_name = method->name();

      const google::protobuf::Descriptor * method_input = method->input_type();
      const std::string method_input_fullname = method_input->full_name();
      const std::string & method_input_name = method_input->name();

      const google::protobuf::Descriptor * method_output = method->output_type();
      const std::string method_output_fullname = method_output->full_name();
      const std::string & method_output_name = method_output->name();

      ss << "      \"" << method_name << "\",\n";
    }
    ss << "      NULL\n";
    ss << "    };\n";
    ss << "    return identifiers;\n";
    ss << "  }\n";
    ss << "  \n";
    ss << "  pbop::Status " << service_name << "::Service::InvokeMethod(const size_t & index, const std::string & input, std::string & output) {\n";
    ss << "    switch(index)\n";
    ss << "    {\n";

    //for each methods
    for(int j=0; j<num_methods; j++)
    {
      const google::protobuf::MethodDescriptor * method = service->method(j);
      const std::string method_fullname = method->full_name();
      const std::string & method_name = method->name();

      const google::protobuf::Descriptor * method_input = method->input_type();
      const std::string method_input_fullname = method_input->full_name();
      const std::string & method_input_name = method_input->name();

      const google::protobuf::Descriptor * method_output = method->output_type();
      const std::string method_output_fullname = method_output->full_name();
      const std::string & method_output_name = method_output->name();

      ss << "    case " << j << ":\n";
      ss << "      {\n";
      ss << "        " << method_input_name << " request;\n";
      ss << "        " << method_output_name << " response;\n";
      ss << "        bool success = request.ParseFromString(input);\n";
      ss << "        if (!success)\n";
      ss << "          return Status::Factory::Deserialization(__FUNCTION__, request);\n";
      ss << "        Status status = this->" << method_name << "(request, response);\n";
      ss << "        if (!status.Success())\n";
      ss << "          return status;\n";
      ss << "        success = response.SerializeToString(&output);\n";
      ss << "        if (!success)\n";
      ss << "          return Status::Factory::Serialization(__FUNCTION__, response);\n";
      ss << "      }\n";
      ss << "      break;\n";
    }

    ss << "    default:\n";
    ss << "      //Not implemented\n";
    ss << "      return Status(STATUS_CODE_NOT_IMPLEMENTED, \"Function at index \" + std::to_string((unsigned long long)index) + \" is not implemented.\");\n";
    ss << "    };\n";
    ss << "    \n";
    ss << "    return Status::OK;\n";
    ss << "  }\n";
    ss << "  \n";
  }
  ss << "}; //namespace " << file->package() << "\n";


  //output to cpp file
  google::protobuf::io::ZeroCopyOutputStream * stream = generator_context->Open(cpp_filename.c_str());
  StreamPrinter printer(stream); //StreamPrinter takes ownership of the Stream
  const std::string buffer = ss.str();
  printer.Print(buffer.c_str(), buffer.size());

  return true;
}

bool PluginCodeGenerator::Generate(const google::protobuf::FileDescriptor * file, const std::string & parameter, google::protobuf::compiler::GeneratorContext * generator_context, string * error) const
{
#if 0
  const std::string exe_path = ra::process::GetCurrentProcessPath();
  const std::string exe_filename = ra::filesystem::GetFilename(exe_path.c_str());
  std::string message = __FUNCTION__;
  MessageBoxA(NULL,message.c_str(), exe_filename.c_str(), MB_OK + MB_ICONEXCLAMATION);
  int a = 0;
#endif

  // Debug content of the file
  DebugPrinter debugger(generator_context);
  debugger.PrintFile(file, "debug.txt");

  // Header file
  bool success = GenerateHeader(file, parameter, generator_context, error);
  if (!success)
    return false;

  // Source file
  success = GenerateSource(file, parameter, generator_context, error);
  if (!success)
    return false;

  if (error)
  {
    std::string & e = (*error);
    //e = "unknown error";
  }

  return true;
}
